(self.webpackChunkcomputer_science_stuff=self.webpackChunkcomputer_science_stuff||[]).push([[363],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,u=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=s(n),h=r,m=c["".concat(u,".").concat(h)]||c[h]||d[h]||l;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3771:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return p},Highlight:function(){return d},default:function(){return h}});var a=n(2122),r=n(9756),l=(n(7294),n(3905)),i=["components"],o={},u=void 0,s={type:"mdx",permalink:"/data-structures",source:"@site/src/pages/data-structures.md"},p=[{value:"<strong>Random Access Data Structures</strong>",id:"random-access-data-structures",children:[{value:"<strong>Arrays</strong>",id:"arrays",children:[]},{value:"<strong>ArrayList</strong>",id:"arraylist",children:[]}]},{value:"<strong>Sequential Access Data Structures</strong>",id:"sequential-access-data-structures",children:[{value:"<strong>Stack</strong>",id:"stack",children:[]},{value:"<strong>Queue</strong>",id:"queue",children:[]},{value:"<strong>Linked List</strong>",id:"linked-list",children:[]},{value:"<strong>Doubly Linked List</strong>",id:"doubly-linked-list",children:[]},{value:"<strong>Dictionaries</strong>",id:"dictionaries",children:[]}]},{value:"<strong>Hierarchical Data Structures</strong>",id:"hierarchical-data-structures",children:[{value:"<strong>Trees</strong>",id:"trees",children:[]},{value:'<a id="tries"></a> <strong>Tries</strong>',id:"tries",children:[]},{value:"<strong>Heaps</strong>",id:"heaps",children:[]},{value:"<strong>Graphs</strong>",id:"graphs",children:[]}]}],d=function(e){var t=e.children,n=e.color,a=e.fontColor;return(0,l.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:a?"black":"white",padding:"0.2rem"}},t)},c={toc:p,Highlight:d};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"data-structure-cheatsheet"},"Data Structure Cheatsheet"),(0,l.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Heads Up")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"btw this is in java so ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value"},"pass-by-value")))),(0,l.kt)("h2",{id:"random-access-data-structures"},(0,l.kt)("strong",{parentName:"h2"},"Random Access Data Structures")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"arrays"},(0,l.kt)("strong",{parentName:"h3"},"Arrays")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Non-mutable size => increased speed"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation"),(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(1) "),(0,l.kt)("li",null," Adding/Deleting O(n) "))),(0,l.kt)("li",{parentName:"ul"},"Data is stored directly next to each other in memory which allows for an O(1) access time"),(0,l.kt)("li",{parentName:"ul"},"Optimal usage on less memory machines"),(0,l.kt)("li",{parentName:"ul"},"2 ways of declaration up front or with separate data allocation")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"int[] numbers = {1,2,3,4,5};\n            or\nint[] numbers = new int[5];\n\nnumbers[0]\n//1\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"note"),": Another valid way of writing ",(0,l.kt)("inlineCode",{parentName:"p"},"int[] numbers")," could be ",(0,l.kt)("inlineCode",{parentName:"p"},"int numbers[]")," in java"),(0,l.kt)("h3",{id:"arraylist"},(0,l.kt)("strong",{parentName:"h3"},"ArrayList")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Classical version of an Array"),(0,l.kt)("li",{parentName:"ul"},"The bigger brother of an Array \ud83d\udcaa"),(0,l.kt)("li",{parentName:"ul"},"Dynamic Sizing"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation")," *same as an array*",(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(1) "),(0,l.kt)("li",null," Adding/Deleting O(n) "))),(0,l.kt)("li",{parentName:"ul"},"Common methods:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Add/Remove (self explanitory)"),(0,l.kt)("li",{parentName:"ul"},"Get (call an index, return a value)"),(0,l.kt)("li",{parentName:"ul"},"Clear (remove everything inside the ArrayList)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Everything in an ArrayList is an Object"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Autoboxing:")," Converts the primitive values such as ",(0,l.kt)("code",null,"int"),", ",(0,l.kt)("code",null,"double"),", and ",(0,l.kt)("code",null,"float")," to its class version ie ",(0,l.kt)("code",null,"Integer"),", ",(0,l.kt)("code",null,"Double"),", ",(0,l.kt)("code",null,"Float")))),(0,l.kt)("li",{parentName:"ul"},"Reason for being fast is because it uses an array of pointers to find/access data")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.ArrayList;\n\nArrayList<Integer> numbers = new ArrayList<>(5);\n                             //optional param\n\nnumbers.add(0,5);\n// numbers = {5, null, null, null, null}\n\nnumbers.add(3,6);\n// numbers = {5, null, null, 6, null}\n\nnumbers.get(3)\n//6\n\nnumbers.remove(0,5);\n// numbers = {null, null, null, 6, null}\n\nnumbers.contains(6);\n//true\n\nnumbers.clear();\n// numbers = {null, null, null, null, null}\n")),(0,l.kt)("h2",{id:"sequential-access-data-structures"},(0,l.kt)("strong",{parentName:"h2"},"Sequential Access Data Structures")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"stack"},(0,l.kt)("strong",{parentName:"h3"},"Stack")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Think pancake stack \ud83e\udd5e"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"First In Last Out")," (FILO) principle"),(0,l.kt)("li",{parentName:"ul"},"Access point at the top of the stack"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation"),(0,l.kt)("ul",null,(0,l.kt)("li",null,"Seaching: O(n)"),(0,l.kt)("li",null,"Accessing: O(n)"),(0,l.kt)("li",null,"Adding/Deleting: O(1)"))),(0,l.kt)("li",{parentName:"ul"},"Common Methods:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Push (adds an element to the top of the stack)"),(0,l.kt)("li",{parentName:"ul"},"Pop (removes the top element of the stack)"),(0,l.kt)("li",{parentName:"ul"},"Peek (returns the element at the top of the stack w/o popping it off)"),(0,l.kt)("li",{parentName:"ul"},"Search/Contains (looks through the stack and returns element passed in if it finds it)")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.Stack;\n\nStack<Integer> numbers = new Stack<>();\n\nnumbers.push(0);\n//numbers = {0}\n\nnumbers.push(1);\n//numbers = {0,1}\n\nnumbers.peek();\n//1\n\nnumbers.pop();\n//numbers = {0}\n\nnumbers.contains(7);\n//false\n\n")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"queue"},(0,l.kt)("strong",{parentName:"h3"},"Queue")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The opposite of a stack (think waiting line)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"First In First Out")," (FIFO) principle"),(0,l.kt)("li",{parentName:"ul"},"Access point at the front of the queue"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation")," *same O(n) as a Stack*",(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(n) "),(0,l.kt)("li",null," Adding/Deleting O(1) "))),(0,l.kt)("li",{parentName:"ul"},"Similar Methods as a Stack",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Enqueue (places an element at the beginning of the queue)"),(0,l.kt)("li",{parentName:"ul"},"Dequeue (removes the first element of the queue)"),(0,l.kt)("li",{parentName:"ul"},"Peek (looks at the first element of the queue w/o dequeuing it)"),(0,l.kt)("li",{parentName:"ul"},"Search/Contains (looks through the queue and returns element passed in if it finds it)")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.Queue; //this is an interface\nimport java.util.LinkedList; //we will get to this next\n\nQueue<Integer> numbers = new LinkedList<>();\n\nnumbers.enqueue(5)\n//numbers= {5}\n\nnumbers.enqueue(4)\n//numbers= {5,4}\n\nnumbers.dequeue()\n//numbers= {4}\n\nnumbers.peek()\n//4\n\nnumbers.contains(4)\n//true\n")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"linked-list"},(0,l.kt)("strong",{parentName:"h3"},"Linked List")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A series of Nodes"),(0,l.kt)("li",{parentName:"ul"},"A Node contains ",(0,l.kt)("inlineCode",{parentName:"li"},"data and a pointer to the next Node")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Head Node:")," The first node in the Linked List"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#00B4AB",mdxType:"Highlight"},"Tail Node:")," The last node in the Linked List, points to null"),(0,l.kt)("li",{parentName:"ul"},"Flow of data is one way"),(0,l.kt)("li",{parentName:"ul"},"Access point at head of Linked List"),(0,l.kt)("li",{parentName:"ul"},"Can add Nodes to any point in the Linked List"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation"),(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(n) "),(0,l.kt)("li",null," Adding/Deleting O(n) || O(1)",(0,l.kt)("ul",null,(0,l.kt)("li",null,"Inserting at the beginning is O(1)"),(0,l.kt)("li",null,"Inserting at in the middle is O(n)")))))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"//there is a java class that does this but it serves more as a backing for the queue and stack\n\nclass Node{\n  public int data;\n  public Node next;\n  constructor(int data, Node next){\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList{\n  Node head = new Node(5, null);\n  Node tail = new Node(7,null);\n  \n  head.next = tail;\n\n  //note for these methods if position > linkedlist.size() then it will remove/add to tail\n  public Node add(Node head, Node newNode, int position){\n    if(position == 0){\n      newNode.next = head;\n      return newNode;\n    }\n\n    Node current = head;\n\n    for(int i = 0; i < position - 1; i++){\n      if(current.next == null){\n        break;\n      }\n      else{\n        current = current.next;\n      }\n    }\n    newNode.next = current.next;\n    current.next = newNode;\n    return head;\n  }\n\n  public Node remove(Node head, int position){\n    if(position == 0){\n      Node current = head.next;\n      head.next = null;\n      return current;\n    }\n    Node current = head;\n\n    for(int i = 0; i < position; i++){\n      if(current.next.next == null){\n        break;\n      }\n      else{\n        current = current.next;\n      }\n    }\n    current.next = current.next.next;\n    return head;\n  }\n\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"doubly-linked-list"},(0,l.kt)("strong",{parentName:"h3"},"Doubly Linked List")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Like a linked list but with an additional pointer pointing to the previous element"),(0,l.kt)("li",{parentName:"ul"},"Allows for two way flow of data between points"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation"),(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(n) "),(0,l.kt)("li",null," Adding/Deleting O(n) || O(1)",(0,l.kt)("ul",null,(0,l.kt)("li",null,"Inserting at the beginning is O(1)"),(0,l.kt)("li",null,"Inserting at in the middle is O(n)")))))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Node{\n  public int data;\n  public Node next;\n  public Node prev;\n  constructor(int data){\n    this.data = data;\n  }\n}\n\nclass DoublyLinkedList{\n  Node head = new Node(5);\n  Node tail = new Node(7);\n  head.next = tail;\n  tail.prev = head;\n\n  public Node add(Node head, Node newNode, int position){\n    if(position == 0){\n      newNode.next = head;\n      newNode.prev = null;\n      head.prev = newNode;\n    }\n\n    Node current = head;\n\n    for(int i = 0; i < position; i++){\n      if(current.next == null){\n        newNode.prev = current;\n        current.next = newNode;\n        newNode.next = null;\n        return head;\n      }\n      else{\n        current = current.next;\n      }\n    }\n\n    newNode.prev = current.prev;\n    newNode.next = current; \n    current.prev = newNode; \n    current.prev.next = newNode; \n\n    return head;\n\n  }\n\n  public Node remove(Node head, int position){\n    if(position == 0){\n      head.next = null;\n      head.prev = null;\n      head.next.prev = null;\n    }\n\n    Node current = head;\n\n    for(int i = 0; i < position; i++){\n      if(current.next == null){\n        current.prev = null;\n        current.prev.next = null;\n        return head;\n      }\n      else{\n        current = current.next;\n      }\n    }\n\n    current.next.prev = current.prev;\n    current.prev.next = current.next;\n    current.next = null;\n    current.prev = null;\n\n    return head;\n  }\n\n}\n\n")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"dictionaries"},(0,l.kt)("strong",{parentName:"h3"},"Dictionaries")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Synonymous with Maps and Associative Arrays"),(0,l.kt)("li",{parentName:"ul"},"First Abstract Data Structure"),(0,l.kt)("li",{parentName:"ul"},"Key and value pair system (think Social Security \ud83d\udcb3 )"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Key:")," Allows for indexing the dictionary using virtually any primitive value, must be unique within the table"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#00B4AB",mdxType:"Highlight"},"Value:")," The corresponding data to the key, there can be duplicates within the dictionary but each key can only have one value (TLDR: 1 key = 1 value)"),(0,l.kt)("li",{parentName:"ul"},"Hash Tables",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Better alternative than an array b/c storage with an array leads to many Nil (null for class values) values"),(0,l.kt)("li",{parentName:"ul"},"Scales! Woohoo!"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Hash Function:")," A specific function that strategically maps it to the table so that it may be retrieved easily - Examples: SHA-256 and MD5 (these are cryptographic hash functions)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#00B4AB",mdxType:"Highlight"},"Hash Collision:")," An instance where the hash function maps to the same value for two unique keys. - Open Addressing: - Placing the key @ an open location (Nil value) - Could cause problems later on if another collision occurs at the new location and could slow down the response time of the hash table - Closed Addressing: - Creates a Linked List at the same value"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Big O Notation"),(0,l.kt)("ul",null,(0,l.kt)("li",null," Searching O(n) "),(0,l.kt)("li",null," Accessing O(n) "),(0,l.kt)("li",null," Adding/Deleting O(n) "),(0,l.kt)("li",null,"Worst case being that all values map to 0 and Linked Lists must be used",(0,l.kt)("ul",null,(0,l.kt)("li",null,"Though average time is O(1) for Search, Accessing, and Adding/Deleting")))))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Hashtable;\n\nHashtable<String, Integer> table = new Hashtable<>();\n\ntable.put("a",1);\n//table = {a=1}\n\ntable.put("b",2);\n//table = {a=1,b=2}\n\ntable.get("a");\n//1\n\ntable.get("c");\n//null\n\ntable.remove("a");\n//table = {b=2}\n\n')),(0,l.kt)("h2",{id:"hierarchical-data-structures"},(0,l.kt)("strong",{parentName:"h2"},"Hierarchical Data Structures")),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"note: there will not be time complexity equations for the hierarchical data structures")),(0,l.kt)("h3",{id:"trees"},(0,l.kt)("strong",{parentName:"h3"},"Trees")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Different from linear/sequential data structures b/c there is no definitive end"),(0,l.kt)("li",{parentName:"ul"},"A collection of Nodes connected together to form a hierarchical representation of the data"),(0,l.kt)("li",{parentName:"ul"},"Similar to Linked List but with more options"),(0,l.kt)("li",{parentName:"ul"},"Terminology:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Vertice:")," A Node on the tree"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#F07178",mdxType:"Highlight"},"Edges:")," The connection between vertices")),(0,l.kt)("hr",{parentName:"li"}),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#C590E8",mdxType:"Highlight"},"Root Node:")," The Topmost Node"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#89DDFF",mdxType:"Highlight"},"Child Node:")," A Node that has an edge connecting to a Node one level above itself"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#B1E16A",mdxType:"Highlight"},"Parent Node:")," Any Node that has 1+ Child Nodes"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Leaf Node:")," Any Node that has no Child Nodes")),(0,l.kt)("hr",{parentName:"li"}),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#F5A3A7",mdxType:"Highlight"},"Height:")," Number of edges on the longest path towards a leaf node"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#00A3E5",mdxType:"Highlight"},"Depth:")," Number of edges required to get from a particular node to the root node"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Binary Search Tree:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Nodes can only have up to 2 children"),(0,l.kt)("li",{parentName:"ul"},"The less or equal to the parent value is on the left branch, the greater or equal to the parent value is on the right branch"),(0,l.kt)("li",{parentName:"ul"},"No 2 Nodes can repeat"),(0,l.kt)("li",{parentName:"ul"},"Search time: O(log(n))")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"//basic binary search tree\n\nclass Node{\n  int data;\n  Node left, right;\n\n  constructor(int data){\n    this.data = data;\n    left = null;\n    right = null;\n  }\n}\n\nclass BinarySearchTree{\n  Node root = new Node(5);\n\n  Node left = new Node(2);\n\n  Node right = new Node(6);\n\n  root.left = left;\n\n  root.right = right;\n}\n\n")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"tries"},(0,l.kt)("a",{id:"tries"})," ",(0,l.kt)("strong",{parentName:"h3"},"Tries")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A tree-like data structure with restrictions"),(0,l.kt)("li",{parentName:"ul"},"Nodes store letters"),(0,l.kt)("li",{parentName:"ul"},"AKA prefix trees & digital trees"),(0,l.kt)("li",{parentName:"ul"},"Word retrieval"),(0,l.kt)("li",{parentName:"ul"},"Starts with an empty root node"),(0,l.kt)("li",{parentName:"ul"},"A letter is linked to the root and its children are the letters of the alphabet that create a valid word"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Flagging:")," A pointer marking the end of a word on the trie")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"heaps"},(0,l.kt)("strong",{parentName:"h3"},"Heaps")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A special tree where all parents are either less than or greater than their children",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#C590E8",mdxType:"Highlight"},"Min Heaps:")," Value of the root is the ",(0,l.kt)("i",null,(0,l.kt)("b",null,"minimum"))," and all parents have smaller values than its children"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#00B4AB",mdxType:"Highlight"},"Max Heaps:")," Value of the root is the ",(0,l.kt)("i",null,(0,l.kt)("b",null,"max"))," and all parents have larger values than its children")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"pseudo-code for now\n\n- given data, the first value becomes the root \n- then recursively go through the list to determine children\n\n- to pop off the top:\n  * remove the root\n  * move to either the furtherest left or right\n  * heapify until heap is sorted\n\n")),(0,l.kt)("h3",{id:"graphs"},(0,l.kt)("strong",{parentName:"h3"},"Graphs")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Composed of Nodes (Verticies) and Edges"),(0,l.kt)("li",{parentName:"ul"},"Finite amount of Nodes and Edges"),(0,l.kt)("li",{parentName:"ul"},"Graph Notation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#C590E8",mdxType:"Highlight"},"Vertice Set:")," List of all Nodes within the graph"),(0,l.kt)("li",{parentName:"ul"},"{1,2,3,4,5}"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#25c2a0",mdxType:"Highlight"},"Edge Set:")," Each element in the set is an ordered pair that represents the relationship between the Nodes"),(0,l.kt)("li",{parentName:"ul"},"{(1,3),(2,1),(3,5),(4,1),(5,4)}")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Nodes that have an edge are dubbed adjacent")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)(d,{color:"#FFD832",fontColor:!0,mdxType:"Highlight"},"Properties of a Graph"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Undirected"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The direction that is being traversed ",(0,l.kt)("strong",{parentName:"li"},"does not")," matter"),(0,l.kt)("li",{parentName:"ul"},"Represented by edges w/o arrows"),(0,l.kt)("li",{parentName:"ul"},"Think friend circle irl"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Directed"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The direction that is being traversed ",(0,l.kt)("strong",{parentName:"li"},"does")," matter"),(0,l.kt)("li",{parentName:"ul"},"Represented by edges w/ arrows"),(0,l.kt)("li",{parentName:"ul"},"Think following people on Twitter"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Cyclic"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Contains a path that connects back to itself"),(0,l.kt)("li",{parentName:"ul"},"All undirected graphs are cyclical"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Acyclic"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"No paths lead back to itself"),(0,l.kt)("li",{parentName:"ul"},"Only can apply to directed graphs"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Weighted Edges"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Numerical value assigned to the edges of a graph",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"AKA the Cost"))),(0,l.kt)("li",{parentName:"ul"},"Usually related to the properties of the graph"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Unweighted Edges"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Every edge is the same value")))))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Example Graphs:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Undirected Cyclical Heaps with Weighted Edges",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Shortest possible path algo"))),(0,l.kt)("li",{parentName:"ul"},"Unweighted Cyclical Graphs (Both Undirected and Directed)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"GraphQL")))))))}h.isMDXComponent=!0}}]);